# AI旅行规划师 - 文件协作关系详解

## 目录
1. [系统启动流程](#系统启动流程)
2. [前端文件协作关系](#前端文件协作关系)
3. [后端文件协作关系](#后端文件协作关系)
4. [完整业务流程示例](#完整业务流程示例)
5. [数据流动图](#数据流动图)

---

## 系统启动流程

### 前端启动流程

```
用户访问网站
    ↓
main.tsx (应用入口)
    ↓
初始化 React 应用
    ↓
App.tsx (根组件)
    ↓
设置路由 (React Router)
    ↓
加载初始页面
```

#### 详细启动过程

**1. main.tsx** - 应用入口点
```typescript
// frontend/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

// 这是整个应用的启动点
// 将 React 应用挂载到 DOM 的 #root 元素上
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```
**职责**: 
- 初始化 React 应用
- 将根组件挂载到 HTML

**2. App.tsx** - 根组件
```typescript
// frontend/src/App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import { useEffect } from 'react'
import { useAuthStore } from './stores/authStore'
import Home from './pages/Home'
import Planning from './pages/Planning'
import Itinerary from './pages/Itinerary'
import Profile from './pages/Profile'
import Auth from './pages/Auth'

function App() {
  const { checkAuth } = useAuthStore()
  
  // 应用启动时检查用户登录状态
  useEffect(() => {
    checkAuth()
  }, [])
  
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/planning" element={<Planning />} />
        <Route path="/itinerary/:id" element={<Itinerary />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="/auth" element={<Auth />} />
      </Routes>
    </BrowserRouter>
  )
}
```
**职责**: 
- 设置路由系统
- 初始化全局状态（检查登录状态）
- 管理页面切换

---

### 后端启动流程

```
npm start
    ↓
app.ts (应用入口)
    ↓
加载配置 (config/)
    ↓
初始化中间件
    ↓
注册路由 (routes/)
    ↓
启动服务器监听端口
```

#### 详细启动过程

**1. app.ts** - 后端入口
```typescript
// backend/src/app.ts
import express from 'express'
import cors from 'cors'
import { config } from './config/env'
import authRoutes from './routes/auth'
import itineraryRoutes from './routes/itinerary'
import budgetRoutes from './routes/budget'
import userRoutes from './routes/user'
import { authMiddleware } from './middleware/auth'
import { errorHandler } from './middleware/error'

const app = express()

// 1. 加载全局中间件
app.use(cors())
app.use(express.json())

// 2. 健康检查端点
app.get('/health', (req, res) => {
  res.json({ status: 'ok' })
})

// 3. 注册路由
app.use('/api/auth', authRoutes)
app.use('/api/itinerary', authMiddleware, itineraryRoutes)
app.use('/api/budget', authMiddleware, budgetRoutes)
app.use('/api/user', authMiddleware, userRoutes)

// 4. 错误处理
app.use(errorHandler)

// 5. 启动服务器
const PORT = config.port || 3000
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`)
})

export default app
```
**职责**: 
- 初始化 Express 应用
- 配置中间件
- 注册所有路由
- 启动 HTTP 服务器

---

## 前端文件协作关系

### 1. 状态管理层 (stores/)

状态管理是前端的核心，使用 Zustand 管理全局状态。

#### authStore.ts - 用户认证状态
```typescript
// frontend/src/stores/authStore.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import * as authService from '../services/auth'

interface AuthState {
  user: User | null
  token: string | null
  isAuthenticated: boolean
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  checkAuth: () => Promise<void>
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      
      // 登录操作
      login: async (email, password) => {
        const { user, token } = await authService.login(email, password)
        set({ user, token, isAuthenticated: true })
      },
      
      // 登出操作
      logout: () => {
        authService.logout()
        set({ user: null, token: null, isAuthenticated: false })
      },
      
      // 检查登录状态
      checkAuth: async () => {
        try {
          const user = await authService.getCurrentUser()
          set({ user, isAuthenticated: true })
        } catch {
          set({ user: null, isAuthenticated: false })
        }
      },
    }),
    {
      name: 'auth-storage', // localStorage 的 key
    }
  )
)
```
**职责**: 
- 管理用户登录状态
- 存储用户信息和 token
- 提供登录/登出方法
- 持久化到 localStorage

**与其他文件的关系**:
- 调用 `services/auth.ts` 与后端通信
- 被 `App.tsx` 调用检查登录状态
- 被 `pages/Auth/` 页面调用执行登录
- 被所有需要用户信息的组件调用

---

#### itineraryStore.ts - 行程管理状态
```typescript
// frontend/src/stores/itineraryStore.ts
import { create } from 'zustand'
import * as itineraryService from '../services/itinerary'

interface ItineraryState {
  itineraries: Itinerary[]
  currentItinerary: Itinerary | null
  isGenerating: boolean
  
  fetchItineraries: () => Promise<void>
  generateItinerary: (requirements: Requirements) => Promise<void>
  updateItinerary: (id: string, data: Partial<Itinerary>) => Promise<void>
  deleteItinerary: (id: string) => Promise<void>
  setCurrentItinerary: (id: string) => void
}

export const useItineraryStore = create<ItineraryState>((set, get) => ({
  itineraries: [],
  currentItinerary: null,
  isGenerating: false,
  
  // 获取所有行程
  fetchItineraries: async () => {
    const itineraries = await itineraryService.getItineraries()
    set({ itineraries })
  },
  
  // 生成新行程
  generateItinerary: async (requirements) => {
    set({ isGenerating: true })
    try {
      const itinerary = await itineraryService.generateItinerary(requirements)
      set(state => ({ 
        itineraries: [...state.itineraries, itinerary],
        isGenerating: false 
      }))
    } catch (error) {
      set({ isGenerating: false })
      throw error
    }
  },
  
  // 更新行程
  updateItinerary: async (id, data) => {
    await itineraryService.updateItinerary(id, data)
    set(state => ({
      itineraries: state.itineraries.map(it => 
        it.id === id ? { ...it, ...data } : it
      )
    }))
  },
  
  // 删除行程
  deleteItinerary: async (id) => {
    await itineraryService.deleteItinerary(id)
    set(state => ({
      itineraries: state.itineraries.filter(it => it.id !== id)
    }))
  },
  
  // 设置当前行程
  setCurrentItinerary: (id) => {
    const itinerary = get().itineraries.find(it => it.id === id)
    set({ currentItinerary: itinerary || null })
  },
}))
```
**职责**: 
- 管理所有行程数据
- 管理当前选中的行程
- 提供行程CRUD操作
- 跟踪生成状态

**与其他文件的关系**:
- 调用 `services/itinerary.ts` 与后端通信
- 被 `pages/Planning/` 调用生成行程
- 被 `pages/Itinerary/` 调用显示和编辑行程
- 被 `components/itinerary/` 组件调用

---

#### mapStore.ts - 地图状态
```typescript
// frontend/src/stores/mapStore.ts
import { create } from 'zustand'

interface MapState {
  center: Location
  zoom: number
  markers: Marker[]
  selectedMarker: Marker | null
  
  setCenter: (center: Location) => void
  setZoom: (zoom: number) => void
  addMarker: (marker: Marker) => void
  removeMarker: (id: string) => void
  selectMarker: (id: string) => void
}

export const useMapStore = create<MapState>((set) => ({
  center: { lat: 39.90923, lng: 116.397428 }, // 默认北京
  zoom: 11,
  markers: [],
  selectedMarker: null,
  
  setCenter: (center) => set({ center }),
  setZoom: (zoom) => set({ zoom }),
  
  addMarker: (marker) => set(state => ({
    markers: [...state.markers, marker]
  })),
  
  removeMarker: (id) => set(state => ({
    markers: state.markers.filter(m => m.id !== id)
  })),
  
  selectMarker: (id) => set(state => ({
    selectedMarker: state.markers.find(m => m.id === id) || null
  })),
}))
```
**职责**: 
- 管理地图中心点和缩放级别
- 管理地图标记
- 跟踪选中的标记

---

### 2. 服务层 (services/)

服务层负责与后端API通信，是前端和后端的桥梁。

#### api.ts - API配置
```typescript
// frontend/src/services/api.ts
import axios from 'axios'
import { useAuthStore } from '../stores/authStore'

// 创建 axios 实例
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
  timeout: 30000,
})

// 请求拦截器 - 添加 token
api.interceptors.request.use(
  (config) => {
    const token = useAuthStore.getState().token
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// 响应拦截器 - 处理错误
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // token 过期，清除登录状态
      useAuthStore.getState().logout()
      window.location.href = '/auth'
    }
    return Promise.reject(error)
  }
)
```
**职责**: 
- 配置 axios 实例
- 自动添加认证 token
- 处理全局错误（如 token 过期）

**与其他文件的关系**:
- 被所有 service 文件使用
- 读取 `authStore` 的 token
- 调用 `authStore.logout()` 处理认证错误

---

#### auth.ts - 认证服务
```typescript
// frontend/src/services/auth.ts
import { api } from './api'
import { supabase } from '../config/supabase'

export const register = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signUp({ email, password })
  if (error) throw error
  return data
}

export const login = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({ 
    email, 
    password 
  })
  if (error) throw error
  
  return {
    user: data.user,
    token: data.session?.access_token,
  }
}

export const logout = async () => {
  await supabase.auth.signOut()
}

export const getCurrentUser = async () => {
  const { data: { user } } = await supabase.auth.getUser()
  return user
}
```
**职责**: 
- 封装所有认证相关的 API 调用
- 与 Supabase Auth 交互

**与其他文件的关系**:
- 使用 `api` 实例（虽然这里直接用 Supabase SDK）
- 被 `authStore` 调用
- 被 `pages/Auth/` 页面调用

---

#### itinerary.ts - 行程服务
```typescript
// frontend/src/services/itinerary.ts
import { api } from './api'

export const getItineraries = async () => {
  const response = await api.get('/itinerary/list')
  return response.data
}

export const getItinerary = async (id: string) => {
  const response = await api.get(`/itinerary/${id}`)
  return response.data
}

export const generateItinerary = async (requirements: Requirements) => {
  // 使用 EventSource 处理流式响应
  return new Promise((resolve, reject) => {
    const eventSource = new EventSource(
      `${import.meta.env.VITE_API_URL}/itinerary/generate`,
      {
        method: 'POST',
        body: JSON.stringify(requirements),
      }
    )
    
    let chunks = ''
    
    eventSource.onmessage = (event) => {
      chunks += event.data
    }
    
    eventSource.onerror = () => {
      eventSource.close()
      if (chunks) {
        resolve(JSON.parse(chunks))
      } else {
        reject(new Error('Failed to generate itinerary'))
      }
    }
  })
}

export const updateItinerary = async (id: string, data: Partial<Itinerary>) => {
  const response = await api.put(`/itinerary/${id}`, data)
  return response.data
}

export const deleteItinerary = async (id: string) => {
  await api.delete(`/itinerary/${id}`)
}

export const addEvent = async (itineraryId: string, event: Omit<Event, 'id'>) => {
  const response = await api.post(`/itinerary/${itineraryId}/event`, event)
  return response.data
}

export const updateEvent = async (
  itineraryId: string, 
  eventId: string, 
  data: Partial<Event>
) => {
  const response = await api.put(
    `/itinerary/${itineraryId}/event/${eventId}`, 
    data
  )
  return response.data
}

export const deleteEvent = async (itineraryId: string, eventId: string) => {
  await api.delete(`/itinerary/${itineraryId}/event/${eventId}`)
}
```
**职责**: 
- 封装所有行程相关的 API 调用
- 处理流式响应（行程生成）
- 提供事件的 CRUD 操作

**与其他文件的关系**:
- 使用 `api` 实例
- 被 `itineraryStore` 调用
- 与后端 `routes/itinerary.ts` 通信

---

### 3. 自定义 Hooks (hooks/)

Hooks 封装了可复用的逻辑。

#### useVoice.ts - 语音输入
```typescript
// frontend/src/hooks/useVoice.ts
import { useState, useRef } from 'react'
import { getXunfeiWebSocketURL } from '../utils/xunfei'

export const useVoice = () => {
  const [isRecording, setIsRecording] = useState(false)
  const [transcript, setTranscript] = useState('')
  const wsRef = useRef<WebSocket | null>(null)
  const mediaRecorderRef = useRef<MediaRecorder | null>(null)
  
  const startRecording = async () => {
    // 获取麦克风
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
    const mediaRecorder = new MediaRecorder(stream)
    mediaRecorderRef.current = mediaRecorder
    
    // 建立 WebSocket
    const ws = new WebSocket(getXunfeiWebSocketURL())
    wsRef.current = ws
    
    ws.onopen = () => {
      mediaRecorder.start(100)
    }
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      if (data.code === 0) {
        const text = data.data.result.ws.map(w => w.cw[0].w).join('')
        setTranscript(prev => prev + text)
      }
    }
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0 && ws.readyState === WebSocket.OPEN) {
        // 转换为 base64 并发送
        const reader = new FileReader()
        reader.onload = () => {
          const base64Audio = reader.result?.toString().split(',')[1]
          ws.send(JSON.stringify({
            data: {
              status: 1,
              format: 'audio/L16;rate=16000',
              audio: base64Audio,
            }
          }))
        }
        reader.readAsDataURL(event.data)
      }
    }
    
    setIsRecording(true)
  }
  
  const stopRecording = () => {
    mediaRecorderRef.current?.stop()
    wsRef.current?.send(JSON.stringify({ data: { status: 2 } }))
    wsRef.current?.close()
    setIsRecording(false)
  }
  
  return { isRecording, transcript, startRecording, stopRecording }
}
```
**职责**: 
- 封装语音录制逻辑
- 管理 WebSocket 连接
- 提供录音控制接口

**与其他文件的关系**:
- 使用 `utils/xunfei.ts` 生成 WebSocket URL
- 被 `components/voice/VoiceInput.tsx` 使用
- 直接与科大讯飞 API 通信

---

#### useMap.ts - 地图操作
```typescript
// frontend/src/hooks/useMap.ts
import { useEffect, useRef } from 'react'
import AMapLoader from '@amap/amap-jsapi-loader'

export const useMap = (containerId: string) => {
  const mapRef = useRef<any>(null)
  
  useEffect(() => {
    AMapLoader.load({
      key: import.meta.env.VITE_AMAP_JS_KEY,
      version: '2.0',
      plugins: ['AMap.Marker', 'AMap.Polyline', 'AMap.PlaceSearch'],
    }).then((AMap) => {
      const map = new AMap.Map(containerId, {
        zoom: 11,
        center: [116.397428, 39.90923],
      })
      mapRef.current = map
    })
    
    return () => {
      mapRef.current?.destroy()
    }
  }, [containerId])
  
  const addMarker = (location: Location, options?: any) => {
    if (!mapRef.current) return
    
    const marker = new AMap.Marker({
      position: [location.lng, location.lat],
      ...options,
    })
    mapRef.current.add(marker)
    return marker
  }
  
  const drawRoute = (path: Location[]) => {
    if (!mapRef.current) return
    
    const polyline = new AMap.Polyline({
      path: path.map(p => [p.lng, p.lat]),
      strokeColor: '#3b82f6',
      strokeWeight: 4,
    })
    mapRef.current.add(polyline)
  }
  
  const moveToLocation = (location: Location, zoom?: number) => {
    mapRef.current?.setZoomAndCenter(
      zoom || mapRef.current.getZoom(),
      [location.lng, location.lat],
      false,
      500
    )
  }
  
  return { map: mapRef.current, addMarker, drawRoute, moveToLocation }
}
```
**职责**: 
- 封装高德地图初始化
- 提供地图操作方法
- 管理地图实例生命周期

**与其他文件的关系**:
- 被 `components/map/MapContainer.tsx` 使用
- 读取环境变量中的地图 Key
- 与高德地图 SDK 交互

---

### 4. 页面组件 (pages/)

页面组件是完整的页面视图。

#### Planning/ - 行程规划页面
```typescript
// frontend/src/pages/Planning/index.tsx
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useItineraryStore } from '../../stores/itineraryStore'
import VoiceInput from '../../components/voice/VoiceInput'
import RequirementsForm from '../../components/planning/RequirementsForm'

export default function Planning() {
  const navigate = useNavigate()
  const { generateItinerary, isGenerating } = useItineraryStore()
  const [requirements, setRequirements] = useState<Requirements>({})
  
  const handleVoiceInput = (text: string) => {
    // 解析语音输入，填充表单
    // 这里可以调用后端API或本地解析
    console.log('Voice input:', text)
  }
  
  const handleSubmit = async () => {
    try {
      const itinerary = await generateItinerary(requirements)
      navigate(`/itinerary/${itinerary.id}`)
    } catch (error) {
      console.error('Failed to generate itinerary:', error)
    }
  }
  
  return (
    <div className="planning-page">
      <h1>规划您的旅行</h1>
      
      {/* 语音输入组件 */}
      <VoiceInput onTranscript={handleVoiceInput} />
      
      {/* 需求表单 */}
      <RequirementsForm 
        value={requirements}
        onChange={setRequirements}
      />
      
      {/* 生成按钮 */}
      <button 
        onClick={handleSubmit}
        disabled={isGenerating}
      >
        {isGenerating ? '正在生成...' : '生成行程'}
      </button>
    </div>
  )
}
```
**职责**: 
- 提供行程规划界面
- 协调语音输入和表单输入
- 调用行程生成功能

**数据流**:
1. 用户语音输入 → `VoiceInput` → `handleVoiceInput` → 更新 `requirements`
2. 用户表单输入 → `RequirementsForm` → 更新 `requirements`
3. 点击生成 → `handleSubmit` → `generateItinerary` → 后端API
4. 生成成功 → 跳转到行程详情页

---

#### Itinerary/ - 行程详情页面
```typescript
// frontend/src/pages/Itinerary/index.tsx
import { useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { useItineraryStore } from '../../stores/itineraryStore'
import MapContainer from '../../components/map/MapContainer'
import ItineraryView from '../../components/itinerary/ItineraryView'
import BudgetPanel from '../../components/budget/BudgetPanel'

export default function Itinerary() {
  const { id } = useParams()
  const { currentItinerary, setCurrentItinerary } = useItineraryStore()
  
  useEffect(() => {
    if (id) {
      setCurrentItinerary(id)
    }
  }, [id])
  
  if (!currentItinerary) {
    return <div>加载中...</div>
  }
  
  // 提取所有地点标记
  const markers = currentItinerary.days.flatMap(day =>
    day.events.map(event => ({
      id: event.id,
      lat: event.latitude,
      lng: event.longitude,
      title: event.name,
    }))
  )
  
  return (
    <div className="itinerary-page">
      {/* 左侧：行程详情 */}
      <div className="itinerary-sidebar">
        <ItineraryView itinerary={currentItinerary} />
        <BudgetPanel itinerary={currentItinerary} />
      </div>
      
      {/* 右侧：地图 */}
      <div className="map-container">
        <MapContainer markers={markers} />
      </div>
    </div>
  )
}
```
**职责**: 
- 显示行程详情
- 协调地图和行程列表
- 展示预算信息

**数据流**:
1. URL 参数 → `setCurrentItinerary` → 从 store 获取行程
2. 行程数据 → 提取标记 → `MapContainer` 显示
3. 行程数据 → `ItineraryView` 显示时间线
4. 行程数据 → `BudgetPanel` 显示预算

---

### 5. 通用组件 (components/)

#### map/MapContainer.tsx - 地图容器
```typescript
// frontend/src/components/map/MapContainer.tsx
import { useEffect } from 'react'
import { useMap } from '../../hooks/useMap'
import { useMapStore } from '../../stores/mapStore'

interface MapContainerProps {
  markers: Marker[]
  onMarkerClick?: (marker: Marker) => void
}

export default function MapContainer({ markers, onMarkerClick }: MapContainerProps) {
  const { map, addMarker, drawRoute, moveToLocation } = useMap('map-container')
  const { center } = useMapStore()
  
  // 当标记变化时，更新地图
  useEffect(() => {
    if (!map) return
    
    // 清除旧标记
    map.clearMap()
    
    // 添加新标记
    markers.forEach((marker, index) => {
      const aMapMarker = addMarker(
        { lat: marker.lat, lng: marker.lng },
        {
          title: marker.title,
          label: { content: `${index + 1}` },
        }
      )
      
      aMapMarker.on('click', () => {
        onMarkerClick?.(marker)
      })
    })
    
    // 绘制路线
    if (markers.length > 1) {
      drawRoute(markers)
    }
  }, [map, markers])
  
  return <div id="map-container" className="w-full h-full" />
}
```
**职责**: 
- 渲染地图
- 管理地图标记
- 处理地图交互

**与其他文件的关系**:
- 使用 `useMap` hook
- 使用 `mapStore` 获取地图状态
- 被 `pages/Itinerary/` 使用
- 与高德地图 SDK 交互

---

#### voice/VoiceInput.tsx - 语音输入组件
```typescript
// frontend/src/components/voice/VoiceInput.tsx
import { useVoice } from '../../hooks/useVoice'
import { Mic, MicOff } from 'lucide-react'

interface VoiceInputProps {
  onTranscript: (text: string) => void
}

export default function VoiceInput({ onTranscript }: VoiceInputProps) {
  const { isRecording, transcript, startRecording, stopRecording } = useVoice()
  
  const handleToggle = () => {
    if (isRecording) {
      stopRecording()
      onTranscript(transcript)
    } else {
      startRecording()
    }
  }
  
  return (
    <div className="voice-input">
      <button 
        onClick={handleToggle}
        className={isRecording ? 'recording' : ''}
      >
        {isRecording ? <MicOff /> : <Mic />}
        {isRecording ? '停止录音' : '开始录音'}
      </button>
      
      {transcript && (
        <div className="transcript">
          <p>识别结果：{transcript}</p>
        </div>
      )}
    </div>
  )
}
```
**职责**: 
- 提供语音录制UI
- 显示识别结果
- 触发回调传递文本

---

## 后端文件协作关系

### 1. 配置层 (config/)

#### env.ts - 环境变量配置
```typescript
// backend/src/config/env.ts
import dotenv from 'dotenv'

dotenv.config()

export const config = {
  port: process.env.PORT || 3000,
  nodeEnv: process.env.NODE_ENV || 'development',
  
  supabase: {
    url: process.env.SUPABASE_URL!,
    anonKey: process.env.SUPABASE_ANON_KEY!,
    serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  },
  
  deepseek: {
    apiKey: process.env.DEEPSEEK_API_KEY!,
    baseUrl: 'https://api.deepseek.com/v1',
    model: 'deepseek-chat',
  },
  
  amap: {
    webKey: process.env.AMAP_WEB_KEY!,
    jsKey: process.env.AMAP_JS_KEY!,
  },
  
  xunfei: {
    appId: process.env.XUNFEI_APPID!,
    apiKey: process.env.XUNFEI_API_KEY!,
    apiSecret: process.env.XUNFEI_API_SECRET!,
  },
}
```
**职责**: 
- 加载环境变量
- 统一配置管理
- 类型安全的配置访问

**与其他文件的关系**:
- 被所有需要配置的文件导入
- 读取 `.env` 文件

---

#### database.ts - 数据库配置
```typescript
// backend/src/config/database.ts
import { createClient } from '@supabase/supabase-js'
import { config } from './env'

// 使用 service role key 的客户端（后端使用，绕过 RLS）
export const supabaseAdmin = createClient(
  config.supabase.url,
  config.supabase.serviceRoleKey
)

// 使用 anon key 的客户端（遵守 RLS）
export const supabase = createClient(
  config.supabase.url,
  config.supabase.anonKey
)
```
**职责**: 
- 初始化 Supabase 客户端
- 提供数据库访问接口

---

### 2. 中间件层 (middleware/)

#### auth.ts - 认证中间件
```typescript
// backend/src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express'
import { supabase } from '../config/database'

export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    // 从请求头获取 token
    const token = req.headers.authorization?.replace('Bearer ', '')
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' })
    }
    
    // 验证 token
    const { data: { user }, error } = await supabase.auth.getUser(token)
    
    if (error || !user) {
      return res.status(401).json({ error: 'Invalid token' })
    }
    
    // 将用户信息附加到请求对象
    req.user = user
    next()
  } catch (error) {
    res.status(401).json({ error: 'Authentication failed' })
  }
}
```
**职责**: 
- 验证 JWT token
- 提取用户信息
- 保护需要认证的路由

**与其他文件的关系**:
- 在 `app.ts` 中注册到需要认证的路由
- 使用 `supabase` 验证 token
- 被所有需要认证的路由使用

---

#### error.ts - 错误处理中间件
```typescript
// backend/src/middleware/error.ts
import { Request, Response, NextFunction } from 'express'

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error('Error:', error)
  
  res.status(500).json({
    error: error.message || 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
  })
}
```
**职责**: 
- 捕获所有未处理的错误
- 格式化错误响应
- 开发环境显示堆栈信息

---

### 3. 路由层 (routes/)

#### itinerary.ts - 行程路由
```typescript
// backend/src/routes/itinerary.ts
import { Router } from 'express'
import * as itineraryService from '../services/itinerary/generator'
import { supabaseAdmin } from '../config/database'

const router = Router()

// 获取用户的所有行程
router.get('/list', async (req, res, next) => {
  try {
    const userId = req.user.id
    
    const { data, error } = await supabaseAdmin
      .from('itineraries')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
    
    if (error) throw error
    
    res.json(data)
  } catch (error) {
    next(error)
  }
})

// 生成行程（流式响应）
router.post('/generate', async (req, res, next) => {
  try {
    const userId = req.user.id
    const requirements = req.body
    
    // 设置流式响应头
    res.setHeader('Content-Type', 'text/event-stream')
    res.setHeader('Cache-Control', 'no-cache')
    res.setHeader('Connection', 'keep-alive')
    
    // 调用服务生成行程
    const stream = await itineraryService.generateItinerary(requirements, userId)
    
    // 转发流式数据
    for await (const chunk of stream) {
      res.write(`data: ${JSON.stringify(chunk)}\n\n`)
    }
    
    res.end()
  } catch (error) {
    next(error)
  }
})

// 获取单个行程详情
router.get('/:id', async (req, res, next) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    
    const { data, error } = await supabaseAdmin
      .from('itineraries')
      .select(`
        *,
        itinerary_days (
          *,
          events (*)
        ),
        budgets (*)
      `)
      .eq('id', id)
      .eq('user_id', userId)
      .single()
    
    if (error) throw error
    
    res.json(data)
  } catch (error) {
    next(error)
  }
})

// 更新行程
router.put('/:id', async (req, res, next) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    const updates = req.body
    
    const { data, error } = await supabaseAdmin
      .from('itineraries')
      .update(updates)
      .eq('id', id)
      .eq('user_id', userId)
      .single()
    
    if (error) throw error
    
    res.json(data)
  } catch (error) {
    next(error)
  }
})

// 删除行程
router.delete('/:id', async (req, res, next) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    
    const { error } = await supabaseAdmin
      .from('itineraries')
      .delete()
      .eq('id', id)
      .eq('user_id', userId)
    
    if (error) throw error
    
    res.json({ success: true })
  } catch (error) {
    next(error)
  }
})

export default router
```
**职责**: 
- 定义行程相关的 API 端点
- 验证请求参数
- 调用服务层处理业务逻辑
- 返回响应

**与其他文件的关系**:
- 在 `app.ts` 中注册
- 受 `authMiddleware` 保护
- 调用 `services/itinerary/` 服务
- 使用 `supabaseAdmin` 访问数据库
- 被前端 `services/itinerary.ts` 调用

---

### 4. 服务层 (services/)

服务层是后端的业务逻辑核心。

#### services/itinerary/generator.ts - 行程生成服务
```typescript
// backend/src/services/itinerary/generator.ts
import * as llmService from '../llm/planner'
import * as mapService from '../map/poi'
import * as validatorService from './validator'
import { supabaseAdmin } from '../../config/database'

export async function* generateItinerary(
  requirements: Requirements,
  userId: string
) {
  // 第1步：使用 LLM 生成初步行程
  yield { step: 'generating', progress: 0, message: '正在规划行程...' }
  
  const rawItinerary = await llmService.generateItinerary(requirements)
  
  yield { step: 'generating', progress: 30, message: '行程框架已生成' }
  
  // 第2步：验证所有地点
  yield { step: 'validating', progress: 40, message: '正在验证地点...' }
  
  const validatedItinerary = await validatorService.validateLocations(
    rawItinerary,
    requirements.destination
  )
  
  yield { step: 'validating', progress: 60, message: '地点验证完成' }
  
  // 第3步：为每个主要事件获取周边 POI
  yield { step: 'enriching', progress: 70, message: '正在丰富行程内容...' }
  
  for (const day of validatedItinerary.days) {
    for (const event of day.events.filter(e => e.is_main_event)) {
      // 获取周边 POI
      const nearbyPOIs = await mapService.getNearbyPOI(
        { lat: event.latitude, lng: event.longitude },
        event.type
      )
      
      // 使用 LLM 筛选附属事件
      const subEvents = await llmService.selectSubEvents(event, nearbyPOIs)
      
      // 添加附属事件到行程
      day.events.push(...subEvents.map(se => ({
        ...se,
        parent_event_id: event.id,
        is_main_event: false,
      })))
    }
  }
  
  yield { step: 'enriching', progress: 90, message: '行程内容已丰富' }
  
  // 第4步：保存到数据库
  yield { step: 'saving', progress: 95, message: '正在保存行程...' }
  
  const savedItinerary = await saveItinerary(validatedItinerary, userId)
  
  yield { 
    step: 'complete', 
    progress: 100, 
    message: '行程生成完成',
    itinerary: savedItinerary 
  }
}

async function saveItinerary(itinerary: Itinerary, userId: string) {
  // 保存行程主表
  const { data: savedItinerary, error } = await supabaseAdmin
    .from('itineraries')
    .insert({
      user_id: userId,
      title: itinerary.title,
      destination: itinerary.destination,
      start_date: itinerary.start_date,
      end_date: itinerary.end_date,
      days: itinerary.days.length,
      travelers: itinerary.travelers,
      budget: itinerary.budget,
    })
    .select()
    .single()
  
  if (error) throw error
  
  // 保存每天的行程
  for (const [index, day] of itinerary.days.entries()) {
    const { data: savedDay } = await supabaseAdmin
      .from('itinerary_days')
      .insert({
        itinerary_id: savedItinerary.id,
        day_number: index + 1,
        date: day.date,
      })
      .select()
      .single()
    
    // 保存事件
    for (const [eventIndex, event] of day.events.entries()) {
      await supabaseAdmin
        .from('events')
        .insert({
          day_id: savedDay.id,
          event_order: eventIndex,
          type: event.type,
          name: event.name,
          description: event.description,
          start_time: event.start_time,
          estimated_duration: event.estimated_duration,
          estimated_cost: event.estimated_cost,
          latitude: event.latitude,
          longitude: event.longitude,
          address: event.address,
          is_main_event: event.is_main_event,
          parent_event_id: event.parent_event_id,
        })
    }
  }
  
  return savedItinerary
}
```
**职责**: 
- 协调整个行程生成流程
- 调用 LLM 服务
- 调用地图服务
- 调用验证服务
- 保存到数据库
- 提供流式进度反馈

**与其他文件的关系**:
- 被 `routes/itinerary.ts` 调用
- 调用 `services/llm/planner.ts`
- 调用 `services/map/poi.ts`
- 调用 `services/itinerary/validator.ts`
- 使用 `supabaseAdmin` 保存数据

---

#### services/llm/planner.ts - LLM 规划服务
```typescript
// backend/src/services/llm/planner.ts
import axios from 'axios'
import { config } from '../../config/env'

export async function generateItinerary(requirements: Requirements) {
  const prompt = `
    根据以下信息生成${requirements.days}天的旅行计划：
    - 目的地：${requirements.destination}
    - 预算：${requirements.budget}元
    - 人数：${requirements.travelers}人
    - 偏好：${requirements.preferences.join(', ')}
    
    要求：
    1. 每天安排2-4个主要事件（景点、餐厅、娱乐）
    2. 包含具体的地点名称（必须是真实存在的地点）
    3. 安排合理的时间
    
    以JSON格式返回...
  `
  
  const response = await axios.post(
    `${config.deepseek.baseUrl}/chat/completions`,
    {
      model: config.deepseek.model,
      messages: [
        { role: 'system', content: '你是一个专业的旅行规划助手' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.7,
    },
    {
      headers: {
        'Authorization': `Bearer ${config.deepseek.apiKey}`,
        'Content-Type': 'application/json',
      }
    }
  )
  
  const content = response.data.choices[0].message.content
  return JSON.parse(content)
}

export async function selectSubEvents(mainEvent: Event, nearbyPOIs: POI[]) {
  const prompt = `
    主要事件：${mainEvent.name}（${mainEvent.type}）
    时间：${mainEvent.start_time}
    
    周边地点：
    ${nearbyPOIs.map(poi => `- ${poi.name}（${poi.type}，距离${poi.distance}米）`).join('\n')}
    
    请从周边地点中选择1-3个适合顺带游览的地点...
  `
  
  const response = await axios.post(
    `${config.deepseek.baseUrl}/chat/completions`,
    {
      model: config.deepseek.model,
      messages: [{ role: 'user', content: prompt }],
    },
    {
      headers: {
        'Authorization': `Bearer ${config.deepseek.apiKey}`,
      }
    }
  )
  
  const selectedNames = JSON.parse(response.data.choices[0].message.content)
  return nearbyPOIs.filter(poi => selectedNames.includes(poi.name))
}
```
**职责**: 
- 调用 DeepSeek API
- 生成行程建议
- 筛选附属事件

**与其他文件的关系**:
- 被 `services/itinerary/generator.ts` 调用
- 使用 `config` 获取 API key
- 与 DeepSeek API 通信

---

#### services/map/poi.ts - POI 搜索服务
```typescript
// backend/src/services/map/poi.ts
import axios from 'axios'
import { config } from '../../config/env'

const AMAP_BASE_URL = 'https://restapi.amap.com/v3'

export async function getNearbyPOI(
  location: Location,
  type: string,
  radius: number = 1000
) {
  // 根据事件类型映射高德 POI 类型
  const typeMap = {
    'restaurant': '050000', // 餐饮
    'attraction': '110000', // 景点
    'shopping': '060000',   // 购物
    'hotel': '100000',      // 住宿
  }
  
  const response = await axios.get(`${AMAP_BASE_URL}/place/around`, {
    params: {
      key: config.amap.webKey,
      location: `${location.lng},${location.lat}`,
      types: typeMap[type] || '',
      radius,
      offset: 10,
      sortrule: 'distance',
    }
  })
  
  return response.data.pois.map(poi => ({
    name: poi.name,
    type: poi.type,
    location: {
      lat: parseFloat(poi.location.split(',')[1]),
      lng: parseFloat(poi.location.split(',')[0]),
    },
    address: poi.address,
    distance: parseInt(poi.distance),
    poi_id: poi.id,
  }))
}

export async function searchPlace(keywords: string, city: string) {
  const response = await axios.get(`${AMAP_BASE_URL}/place/text`, {
    params: {
      key: config.amap.webKey,
      keywords,
      city,
      citylimit: true,
    }
  })
  
  return response.data.pois
}
```
**职责**: 
- 封装高德地图 Web 服务 API
- 搜索周边 POI
- 搜索地点

**与其他文件的关系**:
- 被 `services/itinerary/generator.ts` 调用
- 被 `services/itinerary/validator.ts` 调用
- 使用 `config` 获取 API key
- 与高德地图 API 通信

---

#### services/itinerary/validator.ts - 地点验证服务
```typescript
// backend/src/services/itinerary/validator.ts
import * as mapService from '../map/poi'

export async function validateLocations(
  itinerary: Itinerary,
  city: string
) {
  // 收集所有需要验证的地点
  const allEvents = itinerary.days.flatMap(day => day.events)
  
  // 并发验证
  const validationResults = await Promise.all(
    allEvents.map(async (event) => {
      try {
        const pois = await mapService.searchPlace(event.name, city)
        
        if (pois && pois.length > 0) {
          const poi = pois[0]
          return {
            ...event,
            location_name: poi.name,
            address: poi.address,
            latitude: parseFloat(poi.location.split(',')[1]),
            longitude: parseFloat(poi.location.split(',')[0]),
            poi_id: poi.id,
            valid: true,
          }
        } else {
          return { ...event, valid: false }
        }
      } catch (error) {
        console.error(`Failed to validate ${event.name}:`, error)
        return { ...event, valid: false }
      }
    })
  )
  
  // 过滤掉无效地点
  const validEvents = validationResults.filter(e => e.valid)
  
  // 重新组织行程
  return {
    ...itinerary,
    days: itinerary.days.map(day => ({
      ...day,
      events: validEvents.filter(e => {
        // 根据原始顺序分配事件到天
        const originalEvent = day.events.find(oe => oe.name === e.name)
        return !!originalEvent
      })
    }))
  }
}
```
**职责**: 
- 验证地点是否存在
- 获取地点坐标信息
- 过滤无效地点

**与其他文件的关系**:
- 被 `services/itinerary/generator.ts` 调用
- 调用 `services/map/poi.ts`

---

## 完整业务流程示例

### 场景：用户生成一个新的旅行行程

让我们通过一个完整的流程，看看各个文件是如何协同工作的：

#### 第1步：用户访问规划页面

```
用户浏览器
  → 访问 /planning
  → React Router 匹配路由
  → 渲染 pages/Planning/index.tsx
```

**涉及文件**:
- `main.tsx` - 应用入口
- `App.tsx` - 路由配置
- `pages/Planning/index.tsx` - 规划页面

---

#### 第2步：用户语音输入需求

```
用户点击"开始录音"
  → VoiceInput.tsx 组件
  → 调用 useVoice hook
  → useVoice.startRecording()
  → 建立 WebSocket 连接到科大讯飞
  → 录制音频并发送
  → 接收识别结果
  → 更新 transcript 状态
  → 回调 onTranscript(text)
  → Planning 页面接收文本
```

**涉及文件**:
- `components/voice/VoiceInput.tsx` - UI组件
- `hooks/useVoice.ts` - 语音逻辑
- `utils/xunfei.ts` - 科大讯飞配置

**数据流**:
```
用户音频 
  → WebSocket 
  → 科大讯飞 API 
  → 文字结果 
  → VoiceInput 组件 
  → Planning 页面
```

---

#### 第3步：用户填写表单并提交

```
用户填写表单
  → RequirementsForm 组件
  → 更新 requirements 状态
  
用户点击"生成行程"
  → Planning.handleSubmit()
  → itineraryStore.generateItinerary(requirements)
  → services/itinerary.generateItinerary()
  → 发送 POST 请求到后端
```

**涉及文件**:
- `components/planning/RequirementsForm.tsx` - 表单组件
- `stores/itineraryStore.ts` - 状态管理
- `services/itinerary.ts` - API 调用
- `services/api.ts` - axios 配置

**数据流**:
```
表单数据 
  → itineraryStore 
  → itinerary service 
  → axios 
  → HTTP POST /api/itinerary/generate
```

---

#### 第4步：后端接收请求

```
请求到达后端
  → Express 路由匹配
  → routes/itinerary.ts
  → POST /generate 路由处理器
  → 执行 authMiddleware（验证 token）
  → 调用 itineraryService.generateItinerary()
```

**涉及文件**:
- `app.ts` - Express 应用
- `middleware/auth.ts` - 认证中间件
- `routes/itinerary.ts` - 路由处理器

**数据流**:
```
HTTP Request 
  → Express 
  → authMiddleware（验证token）
  → 路由处理器
```

---

#### 第5步：后端生成行程

```
services/itinerary/generator.ts 开始工作：

Step 1: 调用 LLM 生成初步行程
  → services/llm/planner.generateItinerary()
  → 发送请求到 DeepSeek API
  → 接收 JSON 格式的行程
  → yield 进度: 30%

Step 2: 验证地点
  → services/itinerary/validator.validateLocations()
  → 对每个地点调用 services/map/poi.searchPlace()
  → 高德地图 API 搜索地点
  → 获取坐标信息
  → 过滤无效地点
  → yield 进度: 60%

Step 3: 丰富行程内容
  → 遍历每个主要事件
  → services/map/poi.getNearbyPOI() 获取周边 POI
  → services/llm/planner.selectSubEvents() 筛选附属事件
  → 添加附属事件到行程
  → yield 进度: 90%

Step 4: 保存到数据库
  → 保存到 itineraries 表
  → 保存到 itinerary_days 表
  → 保存到 events 表
  → yield 进度: 100%
```

**涉及文件**:
- `services/itinerary/generator.ts` - 主要流程
- `services/llm/planner.ts` - LLM 调用
- `services/map/poi.ts` - 地图服务
- `services/itinerary/validator.ts` - 地点验证
- `config/database.ts` - 数据库连接

**外部API调用**:
- DeepSeek API（生成行程、筛选事件）
- 高德地图 API（验证地点、搜索 POI）

**数据库操作**:
- INSERT INTO itineraries
- INSERT INTO itinerary_days
- INSERT INTO events

---

#### 第6步：后端返回流式响应

```
生成器每 yield 一次
  → 路由处理器接收
  → 通过 SSE (Server-Sent Events) 发送给前端
  → res.write(`data: ${JSON.stringify(chunk)}\n\n`)
```

**涉及文件**:
- `routes/itinerary.ts` - 流式响应处理

**数据格式**:
```
data: {"step":"generating","progress":30,"message":"行程框架已生成"}\n\n
data: {"step":"validating","progress":60,"message":"地点验证完成"}\n\n
data: {"step":"complete","progress":100,"itinerary":{...}}\n\n
```

---

#### 第7步：前端接收流式响应

```
services/itinerary.generateItinerary()
  → EventSource 接收数据流
  → 解析每个 chunk
  → 更新 UI 显示进度

完成后：
  → 返回完整行程对象
  → itineraryStore 更新状态
  → 添加到 itineraries 数组
  → 页面导航到 /itinerary/{id}
```

**涉及文件**:
- `services/itinerary.ts` - 处理流式响应
- `stores/itineraryStore.ts` - 更新状态
- `pages/Planning/index.tsx` - 导航跳转

---

#### 第8步：显示行程详情

```
导航到 /itinerary/{id}
  → React Router 匹配
  → 渲染 pages/Itinerary/index.tsx
  → 从 URL 提取 id
  → itineraryStore.setCurrentItinerary(id)
  → 从 store 获取行程数据
  
渲染组件：
  → ItineraryView 显示时间线
  → MapContainer 显示地图和标记
  → BudgetPanel 显示预算
```

**涉及文件**:
- `pages/Itinerary/index.tsx` - 行程详情页
- `components/itinerary/ItineraryView.tsx` - 时间线视图
- `components/map/MapContainer.tsx` - 地图组件
- `components/budget/BudgetPanel.tsx` - 预算面板
- `hooks/useMap.ts` - 地图逻辑

**数据流**:
```
URL参数(id) 
  → itineraryStore 
  → 行程数据 
  → 各个子组件
  
行程数据 
  → 提取标记 
  → MapContainer 
  → 高德地图 SDK 
  → 显示在地图上
```

---

## 数据流动图

### 完整的数据流向图

```
┌─────────────────────────────────────────────────────────────────┐
│                          前端应用                                 │
│                                                                  │
│  用户输入                                                         │
│    ↓                                                             │
│  VoiceInput (语音) / RequirementsForm (表单)                     │
│    ↓                                                             │
│  Planning 页面                                                   │
│    ↓                                                             │
│  itineraryStore.generateItinerary()                              │
│    ↓                                                             │
│  services/itinerary.generateItinerary()                          │
│    ↓                                                             │
│  axios.post() with token                                         │
│    ↓                                                             │
└────┼────────────────────────────────────────────────────────────┘
     │
     │ HTTP POST /api/itinerary/generate
     │ Headers: Authorization: Bearer {token}
     │ Body: { destination, days, budget, ... }
     │
     ↓
┌────┼────────────────────────────────────────────────────────────┐
│    ↓                    后端应用                                 │
│  Express 接收请求                                                │
│    ↓                                                             │
│  authMiddleware 验证 token                                       │
│    ↓                                                             │
│  routes/itinerary.ts POST /generate                              │
│    ↓                                                             │
│  services/itinerary/generator.generateItinerary()                │
│    │                                                             │
│    ├─→ services/llm/planner.generateItinerary()                  │
│    │     ↓                                                       │
│    │   DeepSeek API ────┐                                       │
│    │     ↓              │ 外部API                                │
│    │   返回初步行程      │                                       │
│    │                    │                                       │
│    ├─→ services/itinerary/validator.validateLocations()          │
│    │     ↓                                                       │
│    │   services/map/poi.searchPlace() ──┐                       │
│    │     ↓                               │ 外部API               │
│    │   高德地图 API ────────────────────┘                       │
│    │     ↓                                                       │
│    │   返回有效地点                                               │
│    │                                                             │
│    ├─→ services/map/poi.getNearbyPOI() ──┐                      │
│    │     ↓                                │ 外部API              │
│    │   高德地图 API ─────────────────────┘                      │
│    │     ↓                                                       │
│    │   返回周边POI                                                │
│    │                                                             │
│    ├─→ services/llm/planner.selectSubEvents()                    │
│    │     ↓                                                       │
│    │   DeepSeek API ────┐                                       │
│    │     ↓              │ 外部API                                │
│    │   返回筛选结果      │                                       │
│    │                    │                                       │
│    └─→ saveItinerary()  │                                       │
│          ↓              │                                       │
│        Supabase ────────┘                                       │
│          ↓                                                       │
│        保存成功                                                  │
│          ↓                                                       │
│        返回完整行程                                               │
│          ↓                                                       │
│    流式响应 (SSE)                                                │
│          ↓                                                       │
└──────────┼──────────────────────────────────────────────────────┘
           │
           │ Server-Sent Events
           │ data: {"step":"generating","progress":30}\n\n
           │ data: {"step":"validating","progress":60}\n\n
           │ data: {"step":"complete","itinerary":{...}}\n\n
           │
           ↓
┌──────────┼──────────────────────────────────────────────────────┐
│          ↓                 前端应用                               │
│    EventSource 接收数据流                                        │
│          ↓                                                       │
│    更新进度 UI                                                   │
│          ↓                                                       │
│    完成后返回行程                                                 │
│          ↓                                                       │
│    itineraryStore 更新状态                                       │
│          ↓                                                       │
│    导航到 /itinerary/{id}                                        │
│          ↓                                                       │
│    pages/Itinerary 显示行程                                      │
│          │                                                       │
│          ├─→ ItineraryView (时间线)                              │
│          ├─→ MapContainer (地图)                                 │
│          │     ↓                                                 │
│          │   useMap hook                                         │
│          │     ↓                                                 │
│          │   高德地图 JS SDK ──┐                                 │
│          │     ↓               │ 外部SDK                         │
│          │   显示地图和标记     │                                 │
│          │                     │                                 │
│          └─→ BudgetPanel (预算) │                                │
│                                 │                                │
└─────────────────────────────────┴────────────────────────────────┘
```

---

## 文件间依赖关系总结

### 前端依赖层级

```
页面层 (pages/)
  ↓ 使用
组件层 (components/)
  ↓ 使用
Hooks层 (hooks/)
  ↓ 使用
状态管理层 (stores/)
  ↓ 使用
服务层 (services/)
  ↓ 使用
配置层 (config/, utils/)
```

### 后端依赖层级

```
入口 (app.ts)
  ↓ 注册
中间件 (middleware/)
  ↓ 保护
路由层 (routes/)
  ↓ 调用
服务层 (services/)
  ├─→ LLM 服务 → DeepSeek API
  ├─→ 地图服务 → 高德地图 API
  └─→ 数据库 → Supabase
  ↓ 使用
配置层 (config/)
```

### 跨系统交互

```
前端 services/ 
  ↔ HTTP/SSE 
  ↔ 后端 routes/

前端 hooks/useVoice 
  ↔ WebSocket 
  ↔ 科大讯飞 API

前端 hooks/useMap 
  ↔ JS SDK 
  ↔ 高德地图

后端 services/llm 
  ↔ HTTP 
  ↔ DeepSeek API

后端 services/map 
  ↔ HTTP 
  ↔ 高德地图 API

后端 + 前端 
  ↔ SDK/REST 
  ↔ Supabase
```

---

## 总结

### 关键协作模式

1. **前端状态管理**
   - Zustand stores 管理全局状态
   - 页面和组件通过 store 共享数据
   - Services 负责与后端通信

2. **前端数据流**
   - 用户操作 → 页面组件 → Store → Service → 后端API
   - 后端响应 → Service → Store → 组件 → UI更新

3. **后端分层架构**
   - 路由层：定义API端点
   - 服务层：业务逻辑
   - 数据层：数据库操作

4. **后端数据流**
   - 请求 → 中间件 → 路由 → 服务 → 外部API/数据库
   - 响应 → 服务 → 路由 → 客户端

5. **异步通信**
   - 流式响应（SSE）：行程生成进度
   - WebSocket：实时语音识别
   - REST API：标准CRUD操作

6. **外部服务集成**
   - DeepSeek：LLM行程规划
   - 高德地图：地点验证、POI搜索
   - 科大讯飞：语音识别
   - Supabase：数据存储和认证

这个架构确保了：
- ✅ 清晰的职责分离
- ✅ 良好的可维护性
- ✅ 高度的可扩展性
- ✅ 优秀的用户体验


